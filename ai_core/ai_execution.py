"""
AI Code Execution Engine

Securely executes code generated by the AI with appropriate sandboxing
and security measures. Handles various languages and execution contexts.
"""

import os
import sys
import json
import logging
import time
import enum
import subprocess
import tempfile
from typing import Dict, List, Optional, Any, Union, Set, Tuple
from datetime import datetime
import re
import shutil
import platform
import psutil
import uuid

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s'
)
logger = logging.getLogger(__name__)

class ExecutionSecurity(str, enum.Enum):
    """Security levels for code execution"""
    STRICT = "strict"  # Most restricted
    STANDARD = "standard"  # Default security
    TRUSTED = "trusted"  # Fewer restrictions
    UNSAFE = "unsafe"  # Minimal restrictions (admin only)

class ExecutionEngine:
    """
    AI Code Execution Engine
    
    Securely executes code generated by the AI system with appropriate
    security measures and isolation.
    
    Key capabilities:
    1. Execute code in multiple languages (Python, JavaScript, etc.)
    2. Sandbox execution to prevent security risks
    3. Capture output, errors, and execution metrics
    4. Limit resources and execution time
    5. Provide execution context and state preservation
    """
    
    def __init__(self):
        """Initialize the execution engine"""
        # Track executions
        self.execution_history = []
        self.last_execution_id = None
        self.execution_stats = {
            "total_executions": 0,
            "successful_executions": 0,
            "failed_executions": 0,
            "execution_times": []
        }
        
        # Security settings
        self.security_config = {
            ExecutionSecurity.STRICT: {
                "timeout": 5,  # seconds
                "allow_network": False,
                "allow_file_write": False,
                "allowed_modules": ["math", "random", "datetime", "re", "json", "collections"],
                "max_memory": 100 * 1024 * 1024,  # 100MB
                "max_processes": 1,
                "restricted_imports": [
                    "os", "sys", "subprocess", "socket", "requests", "http",
                    "urllib", "ftplib", "telnetlib", "smtplib", "importlib"
                ]
            },
            ExecutionSecurity.STANDARD: {
                "timeout": 15,  # seconds
                "allow_network": False,
                "allow_file_write": True,
                "allowed_modules": ["*"],  # All modules allowed except restricted ones
                "max_memory": 500 * 1024 * 1024,  # 500MB
                "max_processes": 2,
                "restricted_imports": [
                    "subprocess", "socket", "requests", "http",
                    "urllib", "ftplib", "telnetlib", "smtplib"
                ]
            },
            ExecutionSecurity.TRUSTED: {
                "timeout": 30,  # seconds
                "allow_network": True,
                "allow_file_write": True,
                "allowed_modules": ["*"],  # All modules allowed
                "max_memory": 1024 * 1024 * 1024,  # 1GB
                "max_processes": 5,
                "restricted_imports": ["subprocess"]
            },
            ExecutionSecurity.UNSAFE: {
                "timeout": 60,  # seconds
                "allow_network": True,
                "allow_file_write": True,
                "allowed_modules": ["*"],  # All modules allowed
                "max_memory": 2048 * 1024 * 1024,  # 2GB
                "max_processes": 10,
                "restricted_imports": []  # No restrictions
            }
        }
        
        # Execution environment setup
        self.execution_dir = os.path.join(tempfile.gettempdir(), "ai_execution")
        os.makedirs(self.execution_dir, exist_ok=True)
        
        # Language support configuration
        self.supported_languages = {
            "python": {
                "file_extension": ".py",
                "execute_cmd": ["python", "{file}"],
                "version_cmd": ["python", "--version"],
                "prepare_code": self._prepare_python_code
            },
            "javascript": {
                "file_extension": ".js",
                "execute_cmd": ["node", "{file}"],
                "version_cmd": ["node", "--version"],
                "prepare_code": self._prepare_javascript_code
            },
            "shell": {
                "file_extension": ".sh",
                "execute_cmd": ["bash", "{file}"],
                "version_cmd": ["bash", "--version"],
                "prepare_code": self._prepare_shell_code
            },
            # Add more languages as needed
        }
        
        logger.info("Execution Engine initialized")
    
    def execute_code(
        self,
        code: str,
        language: str,
        context: Optional[Dict[str, Any]] = None,
        security_level: str = "standard"
    ) -> Dict[str, Any]:
        """
        Execute code with appropriate security measures
        
        Args:
            code: Code to execute
            language: Programming language
            context: Execution context variables
            security_level: Security level for execution
            
        Returns:
            Execution result including output, errors, and metrics
        """
        execution_id = str(uuid.uuid4())
        self.last_execution_id = execution_id
        start_time = time.time()
        
        # Default result structure
        result = {
            "id": execution_id,
            "language": language,
            "success": False,
            "output": "",
            "error": "",
            "execution_time": 0,
            "timestamp": datetime.now().isoformat()
        }
        
        logger.info(f"Executing {language} code with security level {security_level}")
        self.execution_stats["total_executions"] += 1
        
        try:
            # Validate language
            if language.lower() not in self.supported_languages:
                raise ValueError(f"Unsupported language: {language}")
            
            language = language.lower()
            language_config = self.supported_languages[language]
            
            # Validate security level
            if security_level not in [s.value for s in ExecutionSecurity]:
                security_level = ExecutionSecurity.STANDARD.value
            
            security_config = self.security_config[ExecutionSecurity(security_level)]
            
            # Create execution directory
            execution_path = os.path.join(self.execution_dir, execution_id)
            os.makedirs(execution_path, exist_ok=True)
            
            # Prepare code with security wrappers
            prepared_code = language_config["prepare_code"](
                code, security_config, context
            )
            
            # Write code to file
            file_extension = language_config["file_extension"]
            file_path = os.path.join(execution_path, f"code{file_extension}")
            
            with open(file_path, "w") as f:
                f.write(prepared_code)
            
            # Execute code
            execute_cmd = [
                cmd.format(file=file_path)
                for cmd in language_config["execute_cmd"]
            ]
            
            # Run with timeout
            timeout = security_config["timeout"]
            
            process = subprocess.Popen(
                execute_cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                cwd=execution_path,
                text=True
            )
            
            try:
                stdout, stderr = process.communicate(timeout=timeout)
                exit_code = process.returncode
                
                # Record result
                result.update({
                    "success": exit_code == 0,
                    "output": stdout,
                    "error": stderr,
                    "exit_code": exit_code
                })
                
                if exit_code == 0:
                    self.execution_stats["successful_executions"] += 1
                else:
                    self.execution_stats["failed_executions"] += 1
                
            except subprocess.TimeoutExpired:
                process.kill()
                stdout, stderr = process.communicate()
                
                result.update({
                    "success": False,
                    "output": stdout,
                    "error": f"Execution timed out after {timeout} seconds",
                    "exit_code": -1
                })
                
                self.execution_stats["failed_executions"] += 1
        
        except Exception as e:
            logger.error(f"Error executing code: {str(e)}")
            result.update({
                "success": False,
                "error": f"Execution engine error: {str(e)}",
                "exit_code": -1
            })
            
            self.execution_stats["failed_executions"] += 1
        
        finally:
            # Calculate execution time
            execution_time = time.time() - start_time
            result["execution_time"] = execution_time
            self.execution_stats["execution_times"].append(execution_time)
            
            # Clean up
            try:
                if os.path.exists(execution_path):
                    shutil.rmtree(execution_path)
            except Exception as e:
                logger.warning(f"Failed to clean up execution directory: {str(e)}")
            
            # Record execution
            self.execution_history.append({
                "id": execution_id,
                "language": language,
                "timestamp": result["timestamp"],
                "success": result["success"],
                "execution_time": execution_time,
                "security_level": security_level
            })
            
            # Limit history size
            if len(self.execution_history) > 100:
                self.execution_history = self.execution_history[-100:]
            
            logger.info(f"Execution completed in {execution_time:.2f}s with {'success' if result['success'] else 'failure'}")
            
            return result
    
    def _prepare_python_code(
        self,
        code: str,
        security_config: Dict[str, Any],
        context: Optional[Dict[str, Any]] = None
    ) -> str:
        """Prepare Python code with security wrappers"""
        # Add security imports and wrappers
        security_header = """
import sys
import os
import importlib
import resource
import signal
from contextlib import redirect_stdout, redirect_stderr
import io
import json
import time

# Set resource limits
"""
        
        # Add resource limits
        security_header += f"""
# Set memory limit ({security_config['max_memory'] // (1024 * 1024)}MB)
resource.setrlimit(resource.RLIMIT_AS, ({security_config['max_memory']}, {security_config['max_memory']}))

# Set process limit ({security_config['max_processes']})
resource.setrlimit(resource.RLIMIT_NPROC, ({security_config['max_processes']}, {security_config['max_processes']}))

# Set CPU time limit ({security_config['timeout']} seconds)
resource.setrlimit(resource.RLIMIT_CPU, ({security_config['timeout']}, {security_config['timeout']}))

def timeout_handler(signum, frame):
    raise TimeoutError("Execution timed out")

signal.signal(signal.SIGALRM, timeout_handler)
signal.alarm({security_config['timeout']})

"""
        
        # Restrict imports if needed
        if security_config["restricted_imports"]:
            imports_str = ", ".join([f'"{mod}"' for mod in security_config["restricted_imports"]])
            security_header += f"""
# Restrict unsafe imports
RESTRICTED_IMPORTS = [{imports_str}]

# Save original __import__
original_import = __import__

def secure_import(name, *args, **kwargs):
    if name in RESTRICTED_IMPORTS:
        raise ImportError(f"Import of {{name}} is restricted for security reasons")
    return original_import(name, *args, **kwargs)

# Replace import function
__builtins__["__import__"] = secure_import

"""
        
        # Restrict network access if needed
        if not security_config["allow_network"]:
            security_header += """
# Block network access
if "socket" in sys.modules:
    sys.modules["socket"].socket = lambda *args, **kwargs: None
if "http" in sys.modules:
    sys.modules["http"].client = None
if "urllib" in sys.modules:
    sys.modules["urllib"].request = None

"""
        
        # Add context variables
        context_setup = ""
        if context:
            context_setup = "# Set context variables\n"
            for key, value in context.items():
                if isinstance(value, str):
                    context_setup += f'{key} = "{value}"\n'
                else:
                    context_setup += f'{key} = {json.dumps(value)}\n'
        
        # Redirect stdout/stderr for capturing
        execution_wrapper = """
# Capture output
stdout_buffer = io.StringIO()
stderr_buffer = io.StringIO()

with redirect_stdout(stdout_buffer), redirect_stderr(stderr_buffer):
    try:
        # Start user code
        """
        
        # Indent user code
        indented_code = "\n        ".join(code.split("\n"))
        
        # Add footer to print results
        footer = """
        # End user code
    except Exception as e:
        print(f"Error: {str(e)}", file=sys.stderr)

# Output captured stdout/stderr
print("--- STDOUT ---")
print(stdout_buffer.getvalue())
print("--- STDERR ---")
print(stderr_buffer.getvalue())
"""
        
        # Combine all parts
        prepared_code = security_header + context_setup + execution_wrapper + indented_code + footer
        
        return prepared_code
    
    def _prepare_javascript_code(
        self,
        code: str,
        security_config: Dict[str, Any],
        context: Optional[Dict[str, Any]] = None
    ) -> str:
        """Prepare JavaScript code with security wrappers"""
        # Add security wrappers
        security_header = """
// Security wrapper for JavaScript execution

// Set timeout
setTimeout(() => {
    console.error("Execution timed out");
    process.exit(1);
}, ${int(security_config['timeout'] * 1000)});

// Capture console output
const originalLog = console.log;
const originalError = console.error;
const originalWarn = console.warn;
const originalInfo = console.info;

let stdoutCapture = [];
let stderrCapture = [];

console.log = (...args) => {
    stdoutCapture.push(args.map(arg => 
        typeof arg === 'object' ? JSON.stringify(arg) : String(arg)).join(' '));
    originalLog(...args);
};

console.error = (...args) => {
    stderrCapture.push(args.map(arg => 
        typeof arg === 'object' ? JSON.stringify(arg) : String(arg)).join(' '));
    originalError(...args);
};

console.warn = (...args) => {
    stderrCapture.push(args.map(arg => 
        typeof arg === 'object' ? JSON.stringify(arg) : String(arg)).join(' '));
    originalWarn(...args);
};

console.info = (...args) => {
    stdoutCapture.push(args.map(arg => 
        typeof arg === 'object' ? JSON.stringify(arg) : String(arg)).join(' '));
    originalInfo(...args);
};

"""
        
        # Restrict network access if needed
        if not security_config["allow_network"]:
            security_header += """
// Block network access
if (typeof require !== 'undefined') {
    const originalRequire = require;
    global.require = function(module) {
        if (['http', 'https', 'net', 'dgram', 'dns', 'tls', 'request'].includes(module)) {
            throw new Error(`Import of ${module} is restricted for security reasons`);
        }
        return originalRequire(module);
    };
}

// Block network APIs in browser context
if (typeof fetch !== 'undefined') {
    global.fetch = function() {
        throw new Error('fetch is restricted for security reasons');
    };
}
if (typeof XMLHttpRequest !== 'undefined') {
    global.XMLHttpRequest = function() {
        throw new Error('XMLHttpRequest is restricted for security reasons');
    };
}

"""
        
        # Restrict dangerous operations
        security_header += """
// Prevent dangerous operations
if (typeof process !== 'undefined') {
    process.binding = function() {
        throw new Error('process.binding is restricted');
    };
    
    // Limit child process spawning
    if (typeof require !== 'undefined') {
        const cp = require('child_process');
        if (cp) {
            cp.spawn = cp.exec = cp.execFile = function() {
                throw new Error('Child process execution is restricted');
            };
        }
    }
}

"""
        
        # Add context variables
        context_setup = ""
        if context:
            context_setup = "// Set context variables\n"
            for key, value in context.items():
                context_setup += f"const {key} = {json.dumps(value)};\n"
        
        # Add execution wrapper
        execution_wrapper = """
// Begin user code
try {
"""
        
        # Indent user code
        indented_code = "\n    ".join(code.split("\n"))
        
        # Add footer to print results
        footer = """
} catch (error) {
    console.error(`Error: ${error.message}`);
    console.error(error.stack);
}

// Output capture summary
process.on('exit', () => {
    console.log("\\n--- STDOUT CAPTURE ---");
    console.log(stdoutCapture.join("\\n"));
    console.log("\\n--- STDERR CAPTURE ---");
    console.log(stderrCapture.join("\\n"));
});
"""
        
        # Combine all parts
        prepared_code = security_header + context_setup + execution_wrapper + indented_code + footer
        
        return prepared_code
    
    def _prepare_shell_code(
        self,
        code: str,
        security_config: Dict[str, Any],
        context: Optional[Dict[str, Any]] = None
    ) -> str:
        """Prepare shell code with security wrappers"""
        # Basic security for shell scripts
        security_header = """#!/bin/bash
# Security wrapper for shell script execution

# Set timeout
timeout_seconds=${security_config['timeout']}

# Function to clean up on exit
cleanup() {
    echo "Script execution completed or terminated"
    exit
}

# Set up timeout
(
    sleep $timeout_seconds
    echo "Execution timed out after $timeout_seconds seconds" >&2
    kill -9 $$
) &
timeout_pid=$!

# Trap cleanup on exit
trap 'kill $timeout_pid 2>/dev/null; cleanup' EXIT INT TERM

# Redirect output
exec 3>&1 4>&2
exec > >(tee /tmp/stdout.$$.log) 2> >(tee /tmp/stderr.$$.log >&2)

"""
        
        # Set up environment variables for context
        context_setup = ""
        if context:
            context_setup = "# Set context variables\n"
            for key, value in context.items():
                if isinstance(value, str):
                    # Escape quotes in string
                    escaped_value = value.replace('"', '\\"')
                    context_setup += f'export {key}="{escaped_value}"\n'
                else:
                    context_setup += f'export {key}=\'{json.dumps(value)}\'\n'
        
        # Combine all parts
        prepared_code = security_header + context_setup + "\n# Begin user code\n" + code + "\n\n# End user code\n"
        
        return prepared_code
    
    def contains_executable_code(self, text: str) -> bool:
        """Check if text contains code blocks that could be executed"""
        # Look for markdown code blocks
        code_block_pattern = r"```(\w+)?\n(.*?)\n```"
        code_blocks = re.findall(code_block_pattern, text, re.DOTALL)
        
        if code_blocks:
            return True
        
        # Look for inline code blocks
        inline_code_pattern = r"`([^`]+)`"
        inline_code_blocks = re.findall(inline_code_pattern, text)
        
        # Check if any inline block looks like a command or code
        for block in inline_code_blocks:
            # If it contains assignment, function call, or other code patterns
            if re.search(r"=|def |function |import |require|print|console\.", block):
                return True
        
        return False
    
    def extract_code_blocks(self, text: str) -> List[Dict[str, Any]]:
        """Extract executable code blocks from text"""
        code_blocks = []
        
        # Extract markdown code blocks
        code_block_pattern = r"```(\w+)?\n(.*?)\n```"
        matches = re.findall(code_block_pattern, text, re.DOTALL)
        
        for language, code in matches:
            # Clean up the language identifier
            if language:
                language = language.lower().strip()
                # Map common language identifiers
                language_mapping = {
                    "py": "python",
                    "js": "javascript",
                    "javascript": "javascript",
                    "node": "javascript",
                    "sh": "shell",
                    "bash": "shell",
                    "shell": "shell"
                }
                language = language_mapping.get(language, language)
            else:
                # Try to guess language from code content
                language = self._guess_language(code)
            
            code_blocks.append({
                "language": language,
                "code": code.strip()
            })
        
        return code_blocks
    
    def _guess_language(self, code: str) -> str:
        """Attempt to guess the programming language from code content"""
        # Very basic language detection
        code = code.strip()
        
        # Check for Python indicators
        if (re.search(r"import\s+\w+|from\s+\w+\s+import|def\s+\w+\s*\(|\sindent|:\s*$", code) or
                code.startswith("#!/usr/bin/env python")):
            return "python"
        
        # Check for JavaScript indicators
        if (re.search(r"var\s+\w+|let\s+\w+|const\s+\w+|function\s+\w+\s*\(|\s=>|require\(|console\.|document\.", code) or
                code.startswith("#!/usr/bin/env node")):
            return "javascript"
        
        # Check for Shell indicators
        if (re.search(r"#!/bin/[bash|sh]|echo\s|export\s|\$\(|\$\w+|if\s+\[\[", code) or
                code.startswith("#!") and ("sh" in code or "bash" in code)):
            return "shell"
        
        # Default to Python as a fallback
        return "python"
    
    def get_memory_usage(self) -> Dict[str, Any]:
        """Get current memory usage of the process"""
        process = psutil.Process(os.getpid())
        memory_info = process.memory_info()
        
        return {
            "rss": memory_info.rss,  # Resident Set Size
            "vms": memory_info.vms,  # Virtual Memory Size
            "rss_mb": memory_info.rss / (1024 * 1024),
            "vms_mb": memory_info.vms / (1024 * 1024)
        }
    
    def get_cpu_usage(self) -> float:
        """Get current CPU usage of the process"""
        process = psutil.Process(os.getpid())
        return process.cpu_percent(interval=0.1)
    
    def get_status(self) -> Dict[str, Any]:
        """Get basic status information"""
        return {
            "total_executions": self.execution_stats["total_executions"],
            "successful_executions": self.execution_stats["successful_executions"],
            "failed_executions": self.execution_stats["failed_executions"],
            "supported_languages": list(self.supported_languages.keys())
        }
    
    def get_detailed_status(self) -> Dict[str, Any]:
        """Get detailed status information"""
        avg_execution_time = 0
        if self.execution_stats["execution_times"]:
            avg_execution_time = sum(self.execution_stats["execution_times"]) / len(self.execution_stats["execution_times"])
        
        return {
            "execution_stats": {
                **self.execution_stats,
                "average_execution_time": avg_execution_time,
                "execution_times": self.execution_stats["execution_times"][-10:]  # Last 10 times
            },
            "recent_executions": self.execution_history[-10:],  # Last 10 executions
            "supported_languages": {
                lang: {
                    "file_extension": config["file_extension"],
                    "execute_cmd": config["execute_cmd"]
                }
                for lang, config in self.supported_languages.items()
            },
            "security_levels": {
                level.value: {
                    k: v for k, v in config.items()
                    if k != "restricted_imports"  # Exclude verbose lists
                }
                for level, config in self.security_config.items()
            },
            "system_info": {
                "platform": platform.platform(),
                "python_version": platform.python_version(),
                "cpu_count": os.cpu_count(),
                "memory_usage": self.get_memory_usage()
            }
        }